/*
==Note==

// 비트 (bit)
// 컴퓨터가 데이터를 저장하는 크기의 최소 단위

// 1Byte의 메모리 공간(number1) 4를 저장한다면 0000,0100
// char => -128~127

// short num2 = 8;
// 2Byte 메모리 공간에 저장하고 해석한다면
// 0000,0000,0000,1000

// 실행했을 때 value에 넣은 데이터를 2진수 형식의 문자열로 바꿔주는 형식



// 비트 연산자 : 비트를 연산하기 위한 연산자

// << : 왼쪽 시프트
// 왼쪽 피연산자의 비트를 두번째 피연산자의 수만큼 왼쪽으로 이동
// 비트를 왼쪽으로 이동(맨 앞 칸은 사라지고 추가된 칸은 0을 저장)

// >> : 오른쪽 시프트
// 왼쪽 피연산자의 비트를 두번째 피연산자의 수만큼 오른쪽으로 이동

// & : 논리곱(AND)
// 두 피연산자의 비트 논리곱을 수행

// | : 논리합(OR)
// 두 피연산자의 비트 논리합을 수행

// ^ : 베타적 논리합 (XOR)
// 두 피연산자의 비트 베타적 논리합을 수행
// 각 자리의 비트를 비교하여 둘 다 같다면 0으로, 다르다면 1로 전환

// ~ : 보수(NOT)
// 피연산자의 비트를 0은 1로, 1은 0으로 반전
*/

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#pragma warning(disable:4996)

const char* convetrB(int value)
{
	static char b[9];
	b[0] = '\0';

	for (int z = 128; z > 0; z >>= 1)
		strcat(b, (value & z) == z ? "1" : "0");

	return b;
}

int main()
{
	int a = 100;

	printf("%d\n%s", a, convetrB(a));

	return 0;
}